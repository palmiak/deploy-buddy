{"version":3,"sources":["@wordpress/data/src/redux-store/metadata/selectors.js"],"names":["getIsResolving","state","selectorName","args","map","undefined","get","hasStartedResolution","hasFinishedResolution","isResolving","getCachedResolvers"],"mappings":";;;;;;;;;;;AAGA;;AAHA;AACA;AACA;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASA,cAAT,CAAyBC,KAAzB,EAAgCC,YAAhC,EAA8CC,IAA9C,EAAqD;AAC3D,QAAMC,GAAG,GAAG,iBAAKH,KAAL,EAAY,CAAEC,YAAF,CAAZ,CAAZ;;AACA,MAAK,CAAEE,GAAP,EAAa;AACZ,WAAOC,SAAP;AACA;;AAED,SAAOD,GAAG,CAACE,GAAJ,CAASH,IAAT,CAAP;AACA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,SAASI,oBAAT,CAA+BN,KAA/B,EAAsCC,YAAtC,EAAoDC,IAAI,GAAG,EAA3D,EAAgE;AACtE,SAAOH,cAAc,CAAEC,KAAF,EAASC,YAAT,EAAuBC,IAAvB,CAAd,KAAgDE,SAAvD;AACA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,SAASG,qBAAT,CAAgCP,KAAhC,EAAuCC,YAAvC,EAAqDC,IAAI,GAAG,EAA5D,EAAiE;AACvE,SAAOH,cAAc,CAAEC,KAAF,EAASC,YAAT,EAAuBC,IAAvB,CAAd,KAAgD,KAAvD;AACA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,SAASM,WAAT,CAAsBR,KAAtB,EAA6BC,YAA7B,EAA2CC,IAAI,GAAG,EAAlD,EAAuD;AAC7D,SAAOH,cAAc,CAAEC,KAAF,EAASC,YAAT,EAAuBC,IAAvB,CAAd,KAAgD,IAAvD;AACA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,SAASO,kBAAT,CAA6BT,KAA7B,EAAqC;AAC3C,SAAOA,KAAP;AACA","sourcesContent":["/**\n * External dependencies\n */\nimport { get } from 'lodash';\n\n/** @typedef {Record<string, import('./reducer').State>} State */\n\n/**\n * Returns the raw `isResolving` value for a given selector name,\n * and arguments set. May be undefined if the selector has never been resolved\n * or not resolved for the given set of arguments, otherwise true or false for\n * resolution started and completed respectively.\n *\n * @param {State}     state        Data state.\n * @param {string}    selectorName Selector name.\n * @param {unknown[]} args         Arguments passed to selector.\n *\n * @return {boolean | undefined} isResolving value.\n */\nexport function getIsResolving( state, selectorName, args ) {\n\tconst map = get( state, [ selectorName ] );\n\tif ( ! map ) {\n\t\treturn undefined;\n\t}\n\n\treturn map.get( args );\n}\n\n/**\n * Returns true if resolution has already been triggered for a given\n * selector name, and arguments set.\n *\n * @param {State}     state        Data state.\n * @param {string}    selectorName Selector name.\n * @param {unknown[]} [args]       Arguments passed to selector (default `[]`).\n *\n * @return {boolean} Whether resolution has been triggered.\n */\nexport function hasStartedResolution( state, selectorName, args = [] ) {\n\treturn getIsResolving( state, selectorName, args ) !== undefined;\n}\n\n/**\n * Returns true if resolution has completed for a given selector\n * name, and arguments set.\n *\n * @param {State}     state        Data state.\n * @param {string}    selectorName Selector name.\n * @param {unknown[]} [args]       Arguments passed to selector.\n *\n * @return {boolean} Whether resolution has completed.\n */\nexport function hasFinishedResolution( state, selectorName, args = [] ) {\n\treturn getIsResolving( state, selectorName, args ) === false;\n}\n\n/**\n * Returns true if resolution has been triggered but has not yet completed for\n * a given selector name, and arguments set.\n *\n * @param {State}     state        Data state.\n * @param {string}    selectorName Selector name.\n * @param {unknown[]} [args]       Arguments passed to selector.\n *\n * @return {boolean} Whether resolution is in progress.\n */\nexport function isResolving( state, selectorName, args = [] ) {\n\treturn getIsResolving( state, selectorName, args ) === true;\n}\n\n/**\n * Returns the list of the cached resolvers.\n *\n * @param {State} state Data state.\n *\n * @return {State} Resolvers mapped by args and selectorName.\n */\nexport function getCachedResolvers( state ) {\n\treturn state;\n}\n"]}