{"version":3,"sources":["@wordpress/components/src/popover/utils.js"],"names":["isRTL","HEIGHT_OFFSET","computePopoverXAxisPosition","anchorRect","contentSize","xAxis","corner","stickyBoundaryElement","chosenYAxis","boundaryElement","forcePosition","forceXAlignment","width","anchorMidPoint","Math","round","left","centerAlignment","popoverLeft","contentWidth","window","innerWidth","leftAlignmentX","right","rightAlignmentX","leftAlignment","rightAlignment","chosenXAxis","chosenWidth","boundaryRect","getBoundingClientRect","min","max","computePopoverYAxisPosition","yAxis","anchorRef","relativeOffsetTop","height","stickyRect","stickyPosition","top","popoverTop","bottom","middleAlignment","contentHeight","innerHeight","topAlignment","bottomAlignment","chosenHeight","computePopoverPosition","position","split","yAxisPosition","xAxisPosition","offsetIframe","rect","ownerDocument","container","defaultView","frameElement","iframeRect","DOMRect"],"mappings":"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","sourcesContent":["// @ts-nocheck\n/**\n * WordPress dependencies\n */\nimport { isRTL } from '@wordpress/i18n';\n\n/**\n * Module constants\n */\nconst HEIGHT_OFFSET = 10; // used by the arrow and a bit of empty space\n\n/**\n * Utility used to compute the popover position over the xAxis\n *\n * @param {Object}  anchorRect            Anchor Rect.\n * @param {Object}  contentSize           Content Size.\n * @param {string}  xAxis                 Desired xAxis.\n * @param {string}  corner                Desired corner.\n * @param {boolean} stickyBoundaryElement The boundary element to use when\n *                                        switching between sticky and normal\n *                                        position.\n * @param {string}  chosenYAxis           yAxis to be used.\n * @param {Element} boundaryElement       Boundary element.\n * @param {boolean} forcePosition         Don't adjust position based on anchor.\n * @param {boolean} forceXAlignment       Don't adjust alignment based on YAxis\n *\n * @return {Object} Popover xAxis position and constraints.\n */\nexport function computePopoverXAxisPosition(\n\tanchorRect,\n\tcontentSize,\n\txAxis,\n\tcorner,\n\tstickyBoundaryElement,\n\tchosenYAxis,\n\tboundaryElement,\n\tforcePosition,\n\tforceXAlignment\n) {\n\tconst { width } = contentSize;\n\n\t// Correct xAxis for RTL support\n\tif ( xAxis === 'left' && isRTL() ) {\n\t\txAxis = 'right';\n\t} else if ( xAxis === 'right' && isRTL() ) {\n\t\txAxis = 'left';\n\t}\n\n\tif ( corner === 'left' && isRTL() ) {\n\t\tcorner = 'right';\n\t} else if ( corner === 'right' && isRTL() ) {\n\t\tcorner = 'left';\n\t}\n\n\t// x axis alignment choices\n\tconst anchorMidPoint = Math.round( anchorRect.left + anchorRect.width / 2 );\n\tconst centerAlignment = {\n\t\tpopoverLeft: anchorMidPoint,\n\t\tcontentWidth:\n\t\t\t( anchorMidPoint - width / 2 > 0 ? width / 2 : anchorMidPoint ) +\n\t\t\t( anchorMidPoint + width / 2 > window.innerWidth\n\t\t\t\t? window.innerWidth - anchorMidPoint\n\t\t\t\t: width / 2 ),\n\t};\n\n\tlet leftAlignmentX = anchorRect.left;\n\n\tif ( corner === 'right' ) {\n\t\tleftAlignmentX = anchorRect.right;\n\t} else if ( chosenYAxis !== 'middle' && ! forceXAlignment ) {\n\t\tleftAlignmentX = anchorMidPoint;\n\t}\n\n\tlet rightAlignmentX = anchorRect.right;\n\n\tif ( corner === 'left' ) {\n\t\trightAlignmentX = anchorRect.left;\n\t} else if ( chosenYAxis !== 'middle' && ! forceXAlignment ) {\n\t\trightAlignmentX = anchorMidPoint;\n\t}\n\n\tconst leftAlignment = {\n\t\tpopoverLeft: leftAlignmentX,\n\t\tcontentWidth: leftAlignmentX - width > 0 ? width : leftAlignmentX,\n\t};\n\tconst rightAlignment = {\n\t\tpopoverLeft: rightAlignmentX,\n\t\tcontentWidth:\n\t\t\trightAlignmentX + width > window.innerWidth\n\t\t\t\t? window.innerWidth - rightAlignmentX\n\t\t\t\t: width,\n\t};\n\n\t// Choosing the x axis\n\tlet chosenXAxis = xAxis;\n\tlet contentWidth = null;\n\n\tif ( ! stickyBoundaryElement && ! forcePosition ) {\n\t\tif ( xAxis === 'center' && centerAlignment.contentWidth === width ) {\n\t\t\tchosenXAxis = 'center';\n\t\t} else if ( xAxis === 'left' && leftAlignment.contentWidth === width ) {\n\t\t\tchosenXAxis = 'left';\n\t\t} else if (\n\t\t\txAxis === 'right' &&\n\t\t\trightAlignment.contentWidth === width\n\t\t) {\n\t\t\tchosenXAxis = 'right';\n\t\t} else {\n\t\t\tchosenXAxis =\n\t\t\t\tleftAlignment.contentWidth > rightAlignment.contentWidth\n\t\t\t\t\t? 'left'\n\t\t\t\t\t: 'right';\n\t\t\tconst chosenWidth =\n\t\t\t\tchosenXAxis === 'left'\n\t\t\t\t\t? leftAlignment.contentWidth\n\t\t\t\t\t: rightAlignment.contentWidth;\n\n\t\t\t// Limit width of the content to the viewport width\n\t\t\tif ( width > window.innerWidth ) {\n\t\t\t\tcontentWidth = window.innerWidth;\n\t\t\t}\n\n\t\t\t// If we can't find any alignment options that could fit\n\t\t\t// our content, then let's fallback to the center of the viewport.\n\t\t\tif ( chosenWidth !== width ) {\n\t\t\t\tchosenXAxis = 'center';\n\t\t\t\tcenterAlignment.popoverLeft = window.innerWidth / 2;\n\t\t\t}\n\t\t}\n\t}\n\n\tlet popoverLeft;\n\tif ( chosenXAxis === 'center' ) {\n\t\tpopoverLeft = centerAlignment.popoverLeft;\n\t} else if ( chosenXAxis === 'left' ) {\n\t\tpopoverLeft = leftAlignment.popoverLeft;\n\t} else {\n\t\tpopoverLeft = rightAlignment.popoverLeft;\n\t}\n\n\tif ( boundaryElement ) {\n\t\tconst boundaryRect = boundaryElement.getBoundingClientRect();\n\t\tpopoverLeft = Math.min( popoverLeft, boundaryRect.right - width );\n\n\t\t// Avoid the popover being position beyond the left boundary if the\n\t\t// direction is left to right.\n\t\tif ( ! isRTL() ) {\n\t\t\tpopoverLeft = Math.max( popoverLeft, 0 );\n\t\t}\n\t}\n\n\treturn {\n\t\txAxis: chosenXAxis,\n\t\tpopoverLeft,\n\t\tcontentWidth,\n\t};\n}\n\n/**\n * Utility used to compute the popover position over the yAxis\n *\n * @param {Object}  anchorRect            Anchor Rect.\n * @param {Object}  contentSize           Content Size.\n * @param {string}  yAxis                 Desired yAxis.\n * @param {string}  corner                Desired corner.\n * @param {boolean} stickyBoundaryElement The boundary element to use when\n *                                        switching between sticky and normal\n *                                        position.\n * @param {Element} anchorRef             The anchor element.\n * @param {Element} relativeOffsetTop     If applicable, top offset of the\n *                                        relative positioned parent container.\n * @param {boolean} forcePosition         Don't adjust position based on anchor.\n *\n * @return {Object} Popover xAxis position and constraints.\n */\nexport function computePopoverYAxisPosition(\n\tanchorRect,\n\tcontentSize,\n\tyAxis,\n\tcorner,\n\tstickyBoundaryElement,\n\tanchorRef,\n\trelativeOffsetTop,\n\tforcePosition\n) {\n\tconst { height } = contentSize;\n\n\tif ( stickyBoundaryElement ) {\n\t\tconst stickyRect = stickyBoundaryElement.getBoundingClientRect();\n\t\tconst stickyPosition = stickyRect.top + height - relativeOffsetTop;\n\n\t\tif ( anchorRect.top <= stickyPosition ) {\n\t\t\treturn {\n\t\t\t\tyAxis,\n\t\t\t\tpopoverTop: Math.min( anchorRect.bottom, stickyPosition ),\n\t\t\t};\n\t\t}\n\t}\n\n\t// y axis alignment choices\n\tlet anchorMidPoint = anchorRect.top + anchorRect.height / 2;\n\n\tif ( corner === 'bottom' ) {\n\t\tanchorMidPoint = anchorRect.bottom;\n\t} else if ( corner === 'top' ) {\n\t\tanchorMidPoint = anchorRect.top;\n\t}\n\n\tconst middleAlignment = {\n\t\tpopoverTop: anchorMidPoint,\n\t\tcontentHeight:\n\t\t\t( anchorMidPoint - height / 2 > 0 ? height / 2 : anchorMidPoint ) +\n\t\t\t( anchorMidPoint + height / 2 > window.innerHeight\n\t\t\t\t? window.innerHeight - anchorMidPoint\n\t\t\t\t: height / 2 ),\n\t};\n\n\tconst topAlignment = {\n\t\tpopoverTop: anchorRect.top,\n\t\tcontentHeight:\n\t\t\tanchorRect.top - HEIGHT_OFFSET - height > 0\n\t\t\t\t? height\n\t\t\t\t: anchorRect.top - HEIGHT_OFFSET,\n\t};\n\tconst bottomAlignment = {\n\t\tpopoverTop: anchorRect.bottom,\n\t\tcontentHeight:\n\t\t\tanchorRect.bottom + HEIGHT_OFFSET + height > window.innerHeight\n\t\t\t\t? window.innerHeight - HEIGHT_OFFSET - anchorRect.bottom\n\t\t\t\t: height,\n\t};\n\n\t// Choosing the y axis\n\tlet chosenYAxis = yAxis;\n\tlet contentHeight = null;\n\n\tif ( ! stickyBoundaryElement && ! forcePosition ) {\n\t\tif ( yAxis === 'middle' && middleAlignment.contentHeight === height ) {\n\t\t\tchosenYAxis = 'middle';\n\t\t} else if ( yAxis === 'top' && topAlignment.contentHeight === height ) {\n\t\t\tchosenYAxis = 'top';\n\t\t} else if (\n\t\t\tyAxis === 'bottom' &&\n\t\t\tbottomAlignment.contentHeight === height\n\t\t) {\n\t\t\tchosenYAxis = 'bottom';\n\t\t} else {\n\t\t\tchosenYAxis =\n\t\t\t\ttopAlignment.contentHeight > bottomAlignment.contentHeight\n\t\t\t\t\t? 'top'\n\t\t\t\t\t: 'bottom';\n\t\t\tconst chosenHeight =\n\t\t\t\tchosenYAxis === 'top'\n\t\t\t\t\t? topAlignment.contentHeight\n\t\t\t\t\t: bottomAlignment.contentHeight;\n\t\t\tcontentHeight = chosenHeight !== height ? chosenHeight : null;\n\t\t}\n\t}\n\n\tlet popoverTop;\n\tif ( chosenYAxis === 'middle' ) {\n\t\tpopoverTop = middleAlignment.popoverTop;\n\t} else if ( chosenYAxis === 'top' ) {\n\t\tpopoverTop = topAlignment.popoverTop;\n\t} else {\n\t\tpopoverTop = bottomAlignment.popoverTop;\n\t}\n\n\treturn {\n\t\tyAxis: chosenYAxis,\n\t\tpopoverTop,\n\t\tcontentHeight,\n\t};\n}\n\n/**\n * Utility used to compute the popover position and the content max width/height\n * for a popover given its anchor rect and its content size.\n *\n * @param {Object}  anchorRect            Anchor Rect.\n * @param {Object}  contentSize           Content Size.\n * @param {string}  position              Position.\n * @param {boolean} stickyBoundaryElement The boundary element to use when\n *                                        switching between sticky and normal\n *                                        position.\n * @param {Element} anchorRef             The anchor element.\n * @param {number}  relativeOffsetTop     If applicable, top offset of the\n *                                        relative positioned parent container.\n * @param {Element} boundaryElement       Boundary element.\n * @param {boolean} forcePosition         Don't adjust position based on anchor.\n * @param {boolean} forceXAlignment       Don't adjust alignment based on YAxis\n *\n * @return {Object} Popover position and constraints.\n */\nexport function computePopoverPosition(\n\tanchorRect,\n\tcontentSize,\n\tposition = 'top',\n\tstickyBoundaryElement,\n\tanchorRef,\n\trelativeOffsetTop,\n\tboundaryElement,\n\tforcePosition,\n\tforceXAlignment\n) {\n\tconst [ yAxis, xAxis = 'center', corner ] = position.split( ' ' );\n\n\tconst yAxisPosition = computePopoverYAxisPosition(\n\t\tanchorRect,\n\t\tcontentSize,\n\t\tyAxis,\n\t\tcorner,\n\t\tstickyBoundaryElement,\n\t\tanchorRef,\n\t\trelativeOffsetTop,\n\t\tforcePosition\n\t);\n\tconst xAxisPosition = computePopoverXAxisPosition(\n\t\tanchorRect,\n\t\tcontentSize,\n\t\txAxis,\n\t\tcorner,\n\t\tstickyBoundaryElement,\n\t\tyAxisPosition.yAxis,\n\t\tboundaryElement,\n\t\tforcePosition,\n\t\tforceXAlignment\n\t);\n\n\treturn {\n\t\t...xAxisPosition,\n\t\t...yAxisPosition,\n\t};\n}\n\n/**\n * Offsets the given rect by the position of the iframe that contains the\n * element. If the owner document is not in an iframe then it returns with the\n * original rect. If the popover container document and the anchor document are\n * the same, the original rect will also be returned.\n *\n * @param {DOMRect}  rect          bounds of the element\n * @param {Document} ownerDocument document of the element\n * @param {Element}  container     The popover container to position.\n *\n * @return {DOMRect} offsetted bounds\n */\nexport function offsetIframe( rect, ownerDocument, container ) {\n\tconst { defaultView } = ownerDocument;\n\tconst { frameElement } = defaultView;\n\n\tif ( ! frameElement || ownerDocument === container.ownerDocument ) {\n\t\treturn rect;\n\t}\n\n\tconst iframeRect = frameElement.getBoundingClientRect();\n\treturn new defaultView.DOMRect(\n\t\trect.left + iframeRect.left,\n\t\trect.top + iframeRect.top,\n\t\trect.width,\n\t\trect.height\n\t);\n}\n"]}