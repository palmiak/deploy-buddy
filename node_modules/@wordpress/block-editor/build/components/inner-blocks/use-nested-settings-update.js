"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = useNestedSettingsUpdate;

var _element = require("@wordpress/element");

var _data = require("@wordpress/data");

var _isShallowEqual = _interopRequireDefault(require("@wordpress/is-shallow-equal"));

var _store = require("../../store");

var _layouts = require("../../layouts");

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/**
 * This hook is a side effect which updates the block-editor store when changes
 * happen to inner block settings. The given props are transformed into a
 * settings object, and if that is different from the current settings object in
 * the block-editor store, then the store is updated with the new settings which
 * came from props.
 *
 * @param {string}   clientId        The client ID of the block to update.
 * @param {string[]} allowedBlocks   An array of block names which are permitted
 *                                   in inner blocks.
 * @param {string}   [templateLock]  The template lock specified for the inner
 *                                   blocks component. (e.g. "all")
 * @param {boolean}  captureToolbars Whether or children toolbars should be shown
 *                                   in the inner blocks component rather than on
 *                                   the child block.
 * @param {string}   orientation     The direction in which the block
 *                                   should face.
 * @param {Object}   layout          The layout object for the block container.
 */
function useNestedSettingsUpdate(clientId, allowedBlocks, templateLock, captureToolbars, orientation, layout) {
  const {
    updateBlockListSettings
  } = (0, _data.useDispatch)(_store.store);
  const {
    blockListSettings,
    parentLock
  } = (0, _data.useSelect)(select => {
    const rootClientId = select(_store.store).getBlockRootClientId(clientId);
    return {
      blockListSettings: select(_store.store).getBlockListSettings(clientId),
      parentLock: select(_store.store).getTemplateLock(rootClientId)
    };
  }, [clientId]); // Memoize as inner blocks implementors often pass a new array on every
  // render.

  const _allowedBlocks = (0, _element.useMemo)(() => allowedBlocks, allowedBlocks);

  (0, _element.useLayoutEffect)(() => {
    const newSettings = {
      allowedBlocks: _allowedBlocks,
      templateLock: templateLock === undefined ? parentLock : templateLock
    }; // These values are not defined for RN, so only include them if they
    // are defined.

    if (captureToolbars !== undefined) {
      newSettings.__experimentalCaptureToolbars = captureToolbars;
    } // Orientation depends on layout,
    // ideally the separate orientation prop should be deprecated.


    if (orientation !== undefined) {
      newSettings.orientation = orientation;
    } else {
      const layoutType = (0, _layouts.getLayoutType)(layout === null || layout === void 0 ? void 0 : layout.type);
      newSettings.orientation = layoutType.getOrientation(layout);
    }

    if (!(0, _isShallowEqual.default)(blockListSettings, newSettings)) {
      updateBlockListSettings(clientId, newSettings);
    }
  }, [clientId, blockListSettings, _allowedBlocks, templateLock, parentLock, captureToolbars, orientation, updateBlockListSettings, layout]);
}
//# sourceMappingURL=use-nested-settings-update.js.map