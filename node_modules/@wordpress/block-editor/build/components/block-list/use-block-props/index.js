"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useBlockProps = useBlockProps;

var _classnames = _interopRequireDefault(require("classnames"));

var _element = require("@wordpress/element");

var _i18n = require("@wordpress/i18n");

var _blocks = require("@wordpress/blocks");

var _compose = require("@wordpress/compose");

var _data = require("@wordpress/data");

var _warning = _interopRequireDefault(require("@wordpress/warning"));

var _useMovingAnimation = _interopRequireDefault(require("../../use-moving-animation"));

var _block = require("../block");

var _useFocusFirstElement = require("./use-focus-first-element");

var _useIsHovered = require("./use-is-hovered");

var _context = require("../../block-edit/context");

var _useBlockClassNames = require("./use-block-class-names");

var _useBlockDefaultClassName = require("./use-block-default-class-name");

var _useBlockCustomClassName = require("./use-block-custom-class-name");

var _useBlockMovingModeClassNames = require("./use-block-moving-mode-class-names");

var _useFocusHandler = require("./use-focus-handler");

var _useSelectedBlockEventHandlers = require("./use-selected-block-event-handlers");

var _useNavModeExit = require("./use-nav-mode-exit");

var _useScrollIntoView = require("./use-scroll-into-view");

var _useBlockRefs = require("./use-block-refs");

var _useMultiSelection = require("./use-multi-selection");

var _useIntersectionObserver = require("./use-intersection-observer");

var _store = require("../../../store");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/**
 * If the block count exceeds the threshold, we disable the reordering animation
 * to avoid laginess.
 */
const BLOCK_ANIMATION_THRESHOLD = 200;
/**
 * This hook is used to lightly mark an element as a block element. The element
 * should be the outermost element of a block. Call this hook and pass the
 * returned props to the element to mark as a block. If you define a ref for the
 * element, it is important to pass the ref to this hook, which the hook in turn
 * will pass to the component through the props it returns. Optionally, you can
 * also pass any other props through this hook, and they will be merged and
 * returned.
 *
 * @param {Object}  props                    Optional. Props to pass to the element. Must contain
 *                                           the ref if one is defined.
 * @param {Object}  options                  Options for internal use only.
 * @param {boolean} options.__unstableIsHtml
 *
 * @return {Object} Props to pass to the element to mark as a block.
 */

function useBlockProps(props = {}, {
  __unstableIsHtml
} = {}) {
  const {
    clientId,
    className,
    wrapperProps = {},
    isAligned
  } = (0, _element.useContext)(_block.BlockListBlockContext);
  const {
    index,
    mode,
    name,
    blockTitle,
    isPartOfSelection,
    adjustScrolling,
    enableAnimation,
    lightBlockWrapper
  } = (0, _data.useSelect)(select => {
    const {
      getBlockRootClientId,
      getBlockIndex,
      getBlockMode,
      getBlockName,
      isTyping,
      getGlobalBlockCount,
      isBlockSelected,
      isBlockMultiSelected,
      isAncestorMultiSelected,
      isFirstMultiSelectedBlock
    } = select(_store.store);
    const isSelected = isBlockSelected(clientId);
    const isPartOfMultiSelection = isBlockMultiSelected(clientId) || isAncestorMultiSelected(clientId);
    const blockName = getBlockName(clientId);
    const rootClientId = getBlockRootClientId(clientId);
    const blockType = (0, _blocks.getBlockType)(blockName);
    return {
      index: getBlockIndex(clientId, rootClientId),
      mode: getBlockMode(clientId),
      name: blockName,
      blockTitle: blockType.title,
      isPartOfSelection: isSelected || isPartOfMultiSelection,
      adjustScrolling: isSelected || isFirstMultiSelectedBlock(clientId),
      enableAnimation: !isTyping() && getGlobalBlockCount() <= BLOCK_ANIMATION_THRESHOLD,
      lightBlockWrapper: blockType.apiVersion > 1 || (0, _blocks.hasBlockSupport)(blockType, 'lightBlockWrapper', false)
    };
  }, [clientId]); // translators: %s: Type of block (i.e. Text, Image etc)

  const blockLabel = (0, _i18n.sprintf)((0, _i18n.__)('Block: %s'), blockTitle);
  const htmlSuffix = mode === 'html' && !__unstableIsHtml ? '-visual' : '';
  const mergedRefs = (0, _compose.useMergeRefs)([props.ref, (0, _useFocusFirstElement.useFocusFirstElement)(clientId), // Must happen after focus because we check for focus in the block.
  (0, _useScrollIntoView.useScrollIntoView)(clientId), (0, _useBlockRefs.useBlockRefProvider)(clientId), (0, _useFocusHandler.useFocusHandler)(clientId), (0, _useMultiSelection.useMultiSelection)(clientId), (0, _useSelectedBlockEventHandlers.useEventHandlers)(clientId), (0, _useNavModeExit.useNavModeExit)(clientId), (0, _useIsHovered.useIsHovered)(), (0, _useIntersectionObserver.useIntersectionObserver)(), (0, _useMovingAnimation.default)({
    isSelected: isPartOfSelection,
    adjustScrolling,
    enableAnimation,
    triggerAnimationOnChange: index
  })]);
  const blockEditContext = (0, _context.useBlockEditContext)(); // Ensures it warns only inside the `edit` implementation for the block.

  if (!lightBlockWrapper && clientId === blockEditContext.clientId) {
    typeof process !== "undefined" && process.env && process.env.NODE_ENV !== "production" ? (0, _warning.default)(`Block type "${name}" must support API version 2 or higher to work correctly with "useBlockProps" method.`) : void 0;
  }

  return { ...wrapperProps,
    ...props,
    ref: mergedRefs,
    id: `block-${clientId}${htmlSuffix}`,
    tabIndex: 0,
    role: 'document',
    'aria-label': blockLabel,
    'data-block': clientId,
    'data-type': name,
    'data-title': blockTitle,
    className: (0, _classnames.default)( // The wp-block className is important for editor styles.
    (0, _classnames.default)('block-editor-block-list__block', {
      'wp-block': !isAligned
    }), className, props.className, wrapperProps.className, (0, _useBlockClassNames.useBlockClassNames)(clientId), (0, _useBlockDefaultClassName.useBlockDefaultClassName)(clientId), (0, _useBlockCustomClassName.useBlockCustomClassName)(clientId), (0, _useBlockMovingModeClassNames.useBlockMovingModeClassNames)(clientId)),
    style: { ...wrapperProps.style,
      ...props.style
    }
  };
}
/**
 * Call within a save function to get the props for the block wrapper.
 *
 * @param {Object} props Optional. Props to pass to the element.
 */


useBlockProps.save = _blocks.__unstableGetBlockProps;
//# sourceMappingURL=index.js.map