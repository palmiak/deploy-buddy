"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _element = require("@wordpress/element");

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _i18n = require("@wordpress/i18n");

var _compose = require("@wordpress/compose");

var _components = require("@wordpress/components");

var _blockSelectionClearer = require("../block-selection-clearer");

var _writingFlow = require("../writing-flow");

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
const BODY_CLASS_NAME = 'editor-styles-wrapper';
const BLOCK_PREFIX = 'wp-block';
/**
 * Clones stylesheets targetting the editor canvas to the given document. A
 * stylesheet is considered targetting the editor a canvas if it contains the
 * `editor-styles-wrapper`, `wp-block`, or `wp-block-*` class selectors.
 *
 * Ideally, this hook should be removed in the future and styles should be added
 * explicitly as editor styles.
 *
 * @param {Document} doc The document to append cloned stylesheets to.
 */

function styleSheetsCompat(doc) {
  // Search the document for stylesheets targetting the editor canvas.
  Array.from(document.styleSheets).forEach(styleSheet => {
    try {
      // May fail for external styles.
      // eslint-disable-next-line no-unused-expressions
      styleSheet.cssRules;
    } catch (e) {
      return;
    }

    const {
      ownerNode,
      cssRules
    } = styleSheet;

    if (!cssRules) {
      return;
    } // Generally, ignore inline styles. We add inline styles belonging to a
    // stylesheet later, which may or may not match the selectors.


    if (ownerNode.tagName !== 'LINK') {
      return;
    } // Don't try to add the reset styles, which were removed as a dependency
    // from `edit-blocks` for the iframe since we don't need to reset admin
    // styles.


    if (ownerNode.id === 'wp-reset-editor-styles-css') {
      return;
    }

    const isMatch = Array.from(cssRules).find(({
      selectorText
    }) => selectorText && (selectorText.includes(`.${BODY_CLASS_NAME}`) || selectorText.includes(`.${BLOCK_PREFIX}`)));

    if (isMatch && !doc.getElementById(ownerNode.id)) {
      // eslint-disable-next-line no-console
      console.error(`Stylesheet ${ownerNode.id} was not properly added.
For blocks, use the block API's style (https://developer.wordpress.org/block-editor/reference-guides/block-api/block-metadata/#style) or editorStyle (https://developer.wordpress.org/block-editor/reference-guides/block-api/block-metadata/#editor-style).
For themes, use add_editor_style (https://developer.wordpress.org/block-editor/how-to-guides/themes/theme-support/#editor-styles).`, ownerNode.outerHTML);
      doc.head.appendChild(ownerNode.cloneNode(true)); // Add inline styles belonging to the stylesheet.

      const inlineCssId = ownerNode.id.replace('-css', '-inline-css');
      const inlineCssElement = document.getElementById(inlineCssId);

      if (inlineCssElement) {
        doc.head.appendChild(inlineCssElement.cloneNode(true));
      }
    }
  });
}
/**
 * Bubbles some event types (keydown, keypress, and dragover) to parent document
 * document to ensure that the keyboard shortcuts and drag and drop work.
 *
 * Ideally, we should remove event bubbling in the future. Keyboard shortcuts
 * should be context dependent, e.g. actions on blocks like Cmd+A should not
 * work globally outside the block editor.
 *
 * @param {Document} doc Document to attach listeners to.
 */


function bubbleEvents(doc) {
  const {
    defaultView
  } = doc;
  const {
    frameElement
  } = defaultView;

  function bubbleEvent(event) {
    const prototype = Object.getPrototypeOf(event);
    const constructorName = prototype.constructor.name;
    const Constructor = window[constructorName];
    const init = {};

    for (const key in event) {
      init[key] = event[key];
    }

    if (event instanceof defaultView.MouseEvent) {
      const rect = frameElement.getBoundingClientRect();
      init.clientX += rect.left;
      init.clientY += rect.top;
    }

    const newEvent = new Constructor(event.type, init);
    const cancelled = !frameElement.dispatchEvent(newEvent);

    if (cancelled) {
      event.preventDefault();
    }
  }

  const eventTypes = ['keydown', 'keypress', 'dragover'];

  for (const name of eventTypes) {
    doc.addEventListener(name, bubbleEvent);
  }
}
/**
 * Sets the document direction.
 *
 * Sets the `editor-styles-wrapper` class name on the body.
 *
 * Copies the `admin-color-*` class name to the body so that the admin color
 * scheme applies to components in the iframe.
 *
 * @param {Document} doc Document to add class name to.
 */


function setBodyClassName(doc) {
  doc.dir = document.dir;
  doc.body.className = BODY_CLASS_NAME;

  for (const name of document.body.classList) {
    if (name.startsWith('admin-color-')) {
      doc.body.classList.add(name);
    } else if (name === 'wp-embed-responsive') {
      // Ideally ALL classes that are added through get_body_class should
      // be added in the editor too, which we'll somehow have to get from
      // the server in the future (which will run the PHP filters).
      doc.body.classList.add('wp-embed-responsive');
    }
  }
}

function useParsedAssets(html) {
  return (0, _element.useMemo)(() => {
    const doc = document.implementation.createHTMLDocument('');
    doc.body.innerHTML = html;
    return Array.from(doc.body.children);
  }, [html]);
}

async function loadScript(doc, {
  id,
  src
}) {
  return new Promise((resolve, reject) => {
    const script = doc.createElement('script');
    script.id = id;

    if (src) {
      script.src = src;

      script.onload = () => resolve();

      script.onerror = () => reject();
    } else {
      resolve();
    }

    doc.head.appendChild(script);
  });
}

function Iframe({
  contentRef,
  children,
  head,
  ...props
}, ref) {
  const [, forceRender] = (0, _element.useReducer)(() => ({}));
  const [iframeDocument, setIframeDocument] = (0, _element.useState)();
  const styles = useParsedAssets(window.__editorAssets.styles);
  const scripts = useParsedAssets(window.__editorAssets.scripts);
  const clearerRef = (0, _blockSelectionClearer.useBlockSelectionClearer)();
  const [before, writingFlowRef, after] = (0, _writingFlow.useWritingFlow)();
  const setRef = (0, _element.useCallback)(node => {
    if (!node) {
      return;
    }

    function setDocumentIfReady() {
      const {
        contentDocument
      } = node;
      const {
        readyState,
        body,
        documentElement
      } = contentDocument;

      if (readyState !== 'interactive' && readyState !== 'complete') {
        return false;
      }

      if (typeof contentRef === 'function') {
        contentRef(body);
      } else if (contentRef) {
        contentRef.current = body;
      }

      setBodyClassName(contentDocument);
      bubbleEvents(contentDocument);
      setBodyClassName(contentDocument);
      setIframeDocument(contentDocument);
      clearerRef(documentElement);
      clearerRef(body);
      writingFlowRef(body);
      scripts.reduce((promise, script) => promise.then(() => loadScript(contentDocument, script)), Promise.resolve()).finally(() => {
        // When script are loaded, re-render blocks to allow them
        // to initialise.
        forceRender();
      });
      return true;
    }

    if (setDocumentIfReady()) {
      return;
    } // Document is not immediately loaded in Firefox.


    node.addEventListener('load', () => {
      setDocumentIfReady();
    });
  }, []);
  (0, _element.useEffect)(() => {
    if (iframeDocument) {
      styleSheetsCompat(iframeDocument);
    }
  }, [iframeDocument]);
  head = (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)("style", null, 'body{margin:0}'), styles.map(({
    tagName,
    href,
    id,
    rel,
    media,
    textContent
  }) => {
    const TagName = tagName.toLowerCase();

    if (TagName === 'style') {
      return (0, _element.createElement)(TagName, {
        id,
        key: id
      }, textContent);
    }

    return (0, _element.createElement)(TagName, {
      href,
      id,
      rel,
      media,
      key: id
    });
  }), head);
  return (0, _element.createElement)(_element.Fragment, null, before, (0, _element.createElement)("iframe", (0, _extends2.default)({}, props, {
    ref: (0, _compose.useMergeRefs)([ref, setRef]),
    tabIndex: "0",
    title: (0, _i18n.__)('Editor canvas'),
    name: "editor-canvas"
  }), iframeDocument && (0, _element.createPortal)((0, _element.createElement)(_components.__experimentalStyleProvider, {
    document: iframeDocument
  }, children), iframeDocument.body), iframeDocument && (0, _element.createPortal)(head, iframeDocument.head)), after);
}

var _default = (0, _element.forwardRef)(Iframe);

exports.default = _default;
//# sourceMappingURL=index.js.map