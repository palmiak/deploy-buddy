"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.RichText = void 0;

var _element = require("@wordpress/element");

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _reactNative = require("react-native");

var _lodash = require("lodash");

var _memize = _interopRequireDefault(require("memize"));

var _reactNativeAztec = _interopRequireDefault(require("@wordpress/react-native-aztec"));

var _reactNativeBridge = require("@wordpress/react-native-bridge");

var _blockEditor = require("@wordpress/block-editor");

var _compose = require("@wordpress/compose");

var _data = require("@wordpress/data");

var _blocks = require("@wordpress/blocks");

var _htmlEntities = require("@wordpress/html-entities");

var _keycodes = require("@wordpress/keycodes");

var _url = require("@wordpress/url");

var _icons = require("@wordpress/icons");

var _i18n = require("@wordpress/i18n");

var _useFormatTypes = require("./use-format-types");

var _formatEdit = _interopRequireDefault(require("./format-edit"));

var _applyFormat = require("../apply-format");

var _getActiveFormat = require("../get-active-format");

var _getActiveFormats = require("../get-active-formats");

var _insert = require("../insert");

var _getTextContent = require("../get-text-content");

var _isEmpty = require("../is-empty");

var _create = require("../create");

var _toHtmlString = require("../to-html-string");

var _removeLineSeparator = require("../remove-line-separator");

var _isCollapsed = require("../is-collapsed");

var _remove = require("../remove");

var _style = _interopRequireDefault(require("./style.scss"));

var _toolbarButtonWithOptions = _interopRequireDefault(require("./toolbar-button-with-options"));

/*eslint no-console: ["error", { allow: ["warn"] }] */

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
const unescapeSpaces = text => {
  return text.replace(/&nbsp;|&#160;/gi, ' ');
};

const gutenbergFormatNamesToAztec = {
  'core/bold': 'bold',
  'core/italic': 'italic',
  'core/strikethrough': 'strikethrough'
};
const EMPTY_PARAGRAPH_TAGS = '<p></p>';

class RichText extends _element.Component {
  constructor({
    value,
    selectionStart,
    selectionEnd,
    __unstableMultilineTag: multiline
  }) {
    super(...arguments);
    this.isMultiline = false;

    if (multiline === true || multiline === 'p' || multiline === 'li') {
      this.multilineTag = multiline === true ? 'p' : multiline;
      this.isMultiline = true;
    }

    if (this.multilineTag === 'li') {
      this.multilineWrapperTags = ['ul', 'ol'];
    }

    this.isIOS = _reactNative.Platform.OS === 'ios';
    this.createRecord = this.createRecord.bind(this);
    this.restoreParagraphTags = this.restoreParagraphTags.bind(this);
    this.onChangeFromAztec = this.onChangeFromAztec.bind(this);
    this.onKeyDown = this.onKeyDown.bind(this);
    this.handleEnter = this.handleEnter.bind(this);
    this.handleDelete = this.handleDelete.bind(this);
    this.onPaste = this.onPaste.bind(this);
    this.onFocus = this.onFocus.bind(this);
    this.onBlur = this.onBlur.bind(this);
    this.onTextUpdate = this.onTextUpdate.bind(this);
    this.onContentSizeChange = this.onContentSizeChange.bind(this);
    this.onFormatChange = this.onFormatChange.bind(this);
    this.formatToValue = (0, _memize.default)(this.formatToValue.bind(this), {
      maxSize: 1
    });
    this.debounceCreateUndoLevel = (0, _lodash.debounce)(this.onCreateUndoLevel, 1000); // This prevents a bug in Aztec which triggers onSelectionChange twice on format change

    this.onSelectionChange = this.onSelectionChange.bind(this);
    this.onSelectionChangeFromAztec = this.onSelectionChangeFromAztec.bind(this);
    this.valueToFormat = this.valueToFormat.bind(this);
    this.getHtmlToRender = this.getHtmlToRender.bind(this);
    this.handleSuggestionFunc = this.handleSuggestionFunc.bind(this);
    this.handleUserSuggestion = this.handleSuggestionFunc(_reactNativeBridge.showUserSuggestions, '@').bind(this);
    this.handleXpostSuggestion = this.handleSuggestionFunc(_reactNativeBridge.showXpostSuggestions, '+').bind(this);
    this.suggestionOptions = this.suggestionOptions.bind(this);
    this.insertString = this.insertString.bind(this);
    this.convertFontSizeFromString = this.convertFontSizeFromString.bind(this);
    this.manipulateEventCounterToForceNativeToRefresh = this.manipulateEventCounterToForceNativeToRefresh.bind(this);
    this.shouldDropEventFromAztec = this.shouldDropEventFromAztec.bind(this);
    this.state = {
      activeFormats: [],
      selectedFormat: null,
      height: 0
    };
    this.needsSelectionUpdate = false;
    this.savedContent = '';
    this.isTouched = false;
    this.lastAztecEventType = null;
    this.lastHistoryValue = value; // Internal values that are update synchronously, unlike props.

    this.value = value;
    this.selectionStart = selectionStart;
    this.selectionEnd = selectionEnd;
  }
  /**
   * Get the current record (value and selection) from props and state.
   *
   * @return {Object} The current record (value and selection).
   */


  getRecord() {
    const {
      selectionStart: start,
      selectionEnd: end
    } = this.props;
    const {
      value
    } = this.props;
    const {
      formats,
      replacements,
      text
    } = this.formatToValue(value);
    const {
      activeFormats
    } = this.state;
    return {
      formats,
      replacements,
      text,
      start,
      end,
      activeFormats
    };
  }
  /**
   * Creates a RichText value "record" from the current content and selection
   * information
   *
   *
   * @return {Object} A RichText value with formats and selection.
   */


  createRecord() {
    const {
      preserveWhiteSpace
    } = this.props;
    const value = {
      start: this.selectionStart,
      end: this.selectionEnd,
      ...(0, _create.create)({
        html: this.value,
        range: null,
        multilineTag: this.multilineTag,
        multilineWrapperTags: this.multilineWrapperTags,
        preserveWhiteSpace
      })
    };
    const start = Math.min(this.selectionStart, value.text.length);
    const end = Math.min(this.selectionEnd, value.text.length);
    return { ...value,
      start,
      end
    };
  }

  valueToFormat(value) {
    // remove the outer root tags
    return this.removeRootTagsProduceByAztec((0, _toHtmlString.toHTMLString)({
      value,
      multilineTag: this.multilineTag
    }));
  }

  getActiveFormatNames(record) {
    const {
      formatTypes
    } = this.props;
    return formatTypes.map(({
      name
    }) => name).filter(name => {
      return (0, _getActiveFormat.getActiveFormat)(record, name) !== undefined;
    }).map(name => gutenbergFormatNamesToAztec[name]).filter(Boolean);
  }

  onFormatChange(record) {
    const {
      start = 0,
      end = 0,
      activeFormats = []
    } = record;
    const changeHandlers = (0, _lodash.pickBy)(this.props, (v, key) => key.startsWith('format_on_change_functions_'));
    Object.values(changeHandlers).forEach(changeHandler => {
      changeHandler(record.formats, record.text);
    });
    this.value = this.valueToFormat(record);
    this.props.onChange(this.value);
    this.setState({
      activeFormats
    });
    this.props.onSelectionChange(start, end);
    this.selectionStart = start;
    this.selectionEnd = end;
    this.onCreateUndoLevel();
    this.lastAztecEventType = 'format change';
  }

  insertString(record, string) {
    if (record && string) {
      this.manipulateEventCounterToForceNativeToRefresh(); // force a refresh on the native side

      const toInsert = (0, _insert.insert)(record, string);
      this.onFormatChange(toInsert);
    }
  }

  onCreateUndoLevel() {
    const {
      __unstableOnCreateUndoLevel: onCreateUndoLevel
    } = this.props; // If the content is the same, no level needs to be created.

    if (this.lastHistoryValue === this.value) {
      return;
    }

    onCreateUndoLevel();
    this.lastHistoryValue = this.value;
  }
  /*
   * Cleans up any root tags produced by aztec.
   * TODO: This should be removed on a later version when aztec doesn't return the top tag of the text being edited
   */


  removeRootTagsProduceByAztec(html) {
    let result = this.removeRootTag(this.props.tagName, html); // Temporary workaround for https://github.com/WordPress/gutenberg/pull/13763

    if (this.props.rootTagsToEliminate) {
      this.props.rootTagsToEliminate.forEach(element => {
        result = this.removeRootTag(element, result);
      });
    }

    if (this.props.tagsToEliminate) {
      this.props.tagsToEliminate.forEach(element => {
        result = this.removeTag(element, result);
      });
    }

    return result;
  }

  removeRootTag(tag, html) {
    const openingTagRegexp = RegExp('^<' + tag + '[^>]*>', 'gim');
    const closingTagRegexp = RegExp('</' + tag + '>$', 'gim');
    return html.replace(openingTagRegexp, '').replace(closingTagRegexp, '');
  }

  removeTag(tag, html) {
    const openingTagRegexp = RegExp('<' + tag + '>', 'gim');
    const closingTagRegexp = RegExp('</' + tag + '>', 'gim');
    return html.replace(openingTagRegexp, '').replace(closingTagRegexp, '');
  } // Fix for crash https://github.com/wordpress-mobile/gutenberg-mobile/issues/2991


  convertFontSizeFromString(fontSize) {
    return fontSize && (0, _lodash.isString)(fontSize) && fontSize.endsWith('px') ? parseFloat(fontSize.substring(0, fontSize.length - 2)) : fontSize;
  }
  /*
   * Handles any case where the content of the AztecRN instance has changed
   */


  onChangeFromAztec(event) {
    if (this.shouldDropEventFromAztec(event, 'onChange')) {
      return;
    }

    const contentWithoutRootTag = this.removeRootTagsProduceByAztec(unescapeSpaces(event.nativeEvent.text)); // On iOS, onChange can be triggered after selection changes, even though there are no content changes.

    if (contentWithoutRootTag === this.value) {
      return;
    }

    this.lastEventCount = event.nativeEvent.eventCount;
    this.comesFromAztec = true;
    this.firedAfterTextChanged = true; // the onChange event always fires after the fact

    this.onTextUpdate(event);
    this.lastAztecEventType = 'input';
  }

  onTextUpdate(event) {
    const contentWithoutRootTag = this.removeRootTagsProduceByAztec(unescapeSpaces(event.nativeEvent.text));
    let formattedContent = contentWithoutRootTag;

    if (!this.isIOS) {
      formattedContent = this.restoreParagraphTags(contentWithoutRootTag, this.multilineTag);
    }

    this.debounceCreateUndoLevel();
    const refresh = this.value !== formattedContent;
    this.value = formattedContent; // we don't want to refresh if our goal is just to create a record

    if (refresh) {
      this.props.onChange(formattedContent);
    }
  }

  restoreParagraphTags(value, tag) {
    if (tag === 'p' && (!value || !value.startsWith('<p>'))) {
      return '<p>' + value + '</p>';
    }

    return value;
  }
  /*
   * Handles any case where the content of the AztecRN instance has changed in size
   */


  onContentSizeChange(contentSize) {
    this.setState(contentSize);
    this.lastAztecEventType = 'content size change';
  }

  onKeyDown(event) {
    var _this$customEditableO;

    if (event.defaultPrevented) {
      return;
    } // Add stubs for conformance in downstream autocompleters logic


    (_this$customEditableO = this.customEditableOnKeyDown) === null || _this$customEditableO === void 0 ? void 0 : _this$customEditableO.call(this, {
      preventDefault: () => undefined,
      ...event
    });
    this.handleDelete(event);
    this.handleEnter(event);
    this.handleTriggerKeyCodes(event);
  }

  handleEnter(event) {
    if (event.keyCode !== _keycodes.ENTER) {
      return;
    }

    const {
      onEnter
    } = this.props;

    if (!onEnter) {
      return;
    }

    onEnter({
      value: this.createRecord(),
      onChange: this.onFormatChange,
      shiftKey: event.shiftKey
    });
    this.lastAztecEventType = 'input';
  }

  handleDelete(event) {
    if (this.shouldDropEventFromAztec(event, 'handleDelete')) {
      return;
    }

    const {
      keyCode
    } = event;

    if (keyCode !== _keycodes.DELETE && keyCode !== _keycodes.BACKSPACE) {
      return;
    }

    const isReverse = keyCode === _keycodes.BACKSPACE;
    const {
      onDelete,
      __unstableMultilineTag: multilineTag
    } = this.props;
    this.lastEventCount = event.nativeEvent.eventCount;
    this.comesFromAztec = true;
    this.firedAfterTextChanged = event.nativeEvent.firedAfterTextChanged;
    const value = this.createRecord();
    const {
      start,
      end,
      text
    } = value;
    let newValue; // Always handle full content deletion ourselves.

    if (start === 0 && end !== 0 && end >= text.length) {
      newValue = (0, _remove.remove)(value);
      this.onFormatChange(newValue);
      event.preventDefault();
      return;
    }

    if (multilineTag) {
      if (isReverse && value.start === 0 && value.end === 0 && (0, _isEmpty.isEmptyLine)(value)) {
        newValue = (0, _removeLineSeparator.removeLineSeparator)(value, !isReverse);
      } else {
        newValue = (0, _removeLineSeparator.removeLineSeparator)(value, isReverse);
      }

      if (newValue) {
        this.onFormatChange(newValue);
        event.preventDefault();
        return;
      }
    } // Only process delete if the key press occurs at an uncollapsed edge.


    if (!onDelete || !(0, _isCollapsed.isCollapsed)(value) || isReverse && start !== 0 || !isReverse && end !== text.length) {
      return;
    }

    onDelete({
      isReverse,
      value
    });
    event.preventDefault();
    this.lastAztecEventType = 'input';
  }

  handleTriggerKeyCodes(event) {
    const {
      keyCode
    } = event;
    const triggeredOption = this.suggestionOptions().find(option => {
      const triggeredKeyCode = option.triggerChar.charCodeAt(0);
      return triggeredKeyCode === keyCode;
    });

    if (triggeredOption) {
      const record = this.getRecord();
      const text = (0, _getTextContent.getTextContent)(record); // Only respond to the trigger if the selection is on the start of text or line
      // or if the character before is a space

      const useTrigger = text.length === 0 || record.start === 0 || text.charAt(record.start - 1) === '\n' || text.charAt(record.start - 1) === ' ';

      if (useTrigger && triggeredOption.onClick) {
        triggeredOption.onClick();
      } else {
        this.insertString(record, triggeredOption.triggerChar);
      }
    }
  }

  suggestionOptions() {
    const {
      areMentionsSupported,
      areXPostsSupported
    } = this.props;
    const allOptions = [{
      supported: areMentionsSupported,
      title: (0, _i18n.__)('Insert mention'),
      onClick: this.handleUserSuggestion,
      triggerChar: '@',
      value: 'mention',
      label: (0, _i18n.__)('Mention'),
      icon: _icons.atSymbol
    }, {
      supported: areXPostsSupported,
      title: (0, _i18n.__)('Insert crosspost'),
      onClick: this.handleXpostSuggestion,
      triggerChar: '+',
      value: 'crosspost',
      label: (0, _i18n.__)('Crosspost'),
      icon: _icons.plus
    }];
    return allOptions.filter(op => op.supported);
  }

  handleSuggestionFunc(suggestionFunction, prefix) {
    return () => {
      const record = this.getRecord();
      suggestionFunction().then(suggestion => {
        this.insertString(record, `${prefix}${suggestion} `);
      }).catch(() => {});
    };
  }
  /**
   * Handles a paste event from the native Aztec Wrapper.
   *
   * @param {Object} event The paste event which wraps `nativeEvent`.
   */


  onPaste(event) {
    const {
      onPaste,
      onChange
    } = this.props;
    const {
      activeFormats = []
    } = this.state;
    const {
      pastedText,
      pastedHtml,
      files
    } = event.nativeEvent;
    const currentRecord = this.createRecord();
    event.preventDefault(); // There is a selection, check if a URL is pasted.

    if (!(0, _isCollapsed.isCollapsed)(currentRecord)) {
      const trimmedText = (pastedHtml || pastedText).replace(/<[^>]+>/g, '').trim(); // A URL was pasted, turn the selection into a link

      if ((0, _url.isURL)(trimmedText)) {
        const linkedRecord = (0, _applyFormat.applyFormat)(currentRecord, {
          type: 'a',
          attributes: {
            href: (0, _htmlEntities.decodeEntities)(trimmedText)
          }
        });
        this.value = this.valueToFormat(linkedRecord);
        onChange(this.value); // Allows us to ask for this information when we get a report.

        window.console.log('Created link:\n\n', trimmedText);
        return;
      }
    }

    if (onPaste) {
      onPaste({
        value: currentRecord,
        onChange: this.onFormatChange,
        html: pastedHtml,
        plainText: pastedText,
        files,
        activeFormats
      });
    }
  }

  onFocus() {
    this.isTouched = true;
    const {
      unstableOnFocus,
      onSelectionChange
    } = this.props;

    if (unstableOnFocus) {
      unstableOnFocus();
    } // We know for certain that on focus, the old selection is invalid. It
    // will be recalculated on `selectionchange`.


    onSelectionChange(this.selectionStart, this.selectionEnd);
    this.lastAztecEventType = 'focus';
  }

  onBlur(event) {
    this.isTouched = false; // Check if value is up to date with latest state of native AztecView

    if (event.nativeEvent.text && event.nativeEvent.text !== this.props.value) {
      this.onTextUpdate(event);
    }

    if (this.props.onBlur) {
      this.props.onBlur(event);
    }

    this.lastAztecEventType = 'blur';
  }

  onSelectionChange(start, end) {
    const hasChanged = this.selectionStart !== start || this.selectionEnd !== end;
    this.selectionStart = start;
    this.selectionEnd = end; // This is a manual selection change event if onChange was not triggered just before
    // and we did not just trigger a text update
    // `onChange` could be the last event and could have been triggered a long time ago so
    // this approach is not perfectly reliable

    const isManual = this.lastAztecEventType !== 'input' && this.props.value === this.value;

    if (hasChanged && isManual) {
      const value = this.createRecord();
      const activeFormats = (0, _getActiveFormats.getActiveFormats)(value);
      this.setState({
        activeFormats
      });
    }

    this.props.onSelectionChange(start, end);
  }

  shouldDropEventFromAztec(event, logText) {
    const shouldDrop = !this.isIOS && event.nativeEvent.eventCount <= this.lastEventCount;

    if (shouldDrop) {
      window.console.log(`Dropping ${logText} from Aztec as its event counter is older than latest sent to the native side. Got ${event.nativeEvent.eventCount} but lastEventCount is ${this.lastEventCount}.`);
    }

    return shouldDrop;
  }

  onSelectionChangeFromAztec(start, end, text, event) {
    if (this.shouldDropEventFromAztec(event, 'onSelectionChange')) {
      return;
    } // `end` can be less than `start` on iOS
    // Let's fix that here so `rich-text/slice` can work properly


    const realStart = Math.min(start, end);
    const realEnd = Math.max(start, end); // check and dicsard stray event, where the text and selection is equal to the ones already cached

    const contentWithoutRootTag = this.removeRootTagsProduceByAztec(unescapeSpaces(event.nativeEvent.text));

    if (contentWithoutRootTag === this.value && realStart === this.selectionStart && realEnd === this.selectionEnd) {
      return;
    }

    this.comesFromAztec = true;
    this.firedAfterTextChanged = true; // Selection change event always fires after the fact
    // update text before updating selection
    // Make sure there are changes made to the content before upgrading it upward

    this.onTextUpdate(event); // Aztec can send us selection change events after it has lost focus.
    // For instance the autocorrect feature will complete a partially written
    // word when resigning focus, causing a selection change event.
    // Forwarding this selection change could cause this RichText to regain
    // focus and start a focus loop.
    //
    // See https://github.com/wordpress-mobile/gutenberg-mobile/issues/1696

    if (this.props.__unstableIsSelected) {
      this.onSelectionChange(realStart, realEnd);
    } // Update lastEventCount to prevent Aztec from re-rendering the content it just sent


    this.lastEventCount = event.nativeEvent.eventCount;
    this.lastAztecEventType = 'selection change';
  }

  isEmpty() {
    return (0, _isEmpty.isEmpty)(this.formatToValue(this.props.value));
  }

  formatToValue(value) {
    const {
      preserveWhiteSpace
    } = this.props; // Handle deprecated `children` and `node` sources.

    if (Array.isArray(value)) {
      return (0, _create.create)({
        html: _blocks.childrenBlock.toHTML(value),
        multilineTag: this.multilineTag,
        multilineWrapperTags: this.multilineWrapperTags,
        preserveWhiteSpace
      });
    }

    if (this.props.format === 'string') {
      return (0, _create.create)({
        html: value,
        multilineTag: this.multilineTag,
        multilineWrapperTags: this.multilineWrapperTags,
        preserveWhiteSpace
      });
    } // Guard for blocks passing `null` in onSplit callbacks. May be removed
    // if onSplit is revised to not pass a `null` value.


    if (value === null) {
      return (0, _create.create)();
    }

    return value;
  }

  manipulateEventCounterToForceNativeToRefresh() {
    if (this.isIOS) {
      this.lastEventCount = undefined;
      return;
    }

    if (typeof this.lastEventCount !== 'undefined') {
      this.lastEventCount += 100; // bump by a hundred, hopefully native hasn't bombarded the JS side in the meantime.
    } else {
      window.console.warn("Tried to bump the RichText native event counter but was 'undefined'. Aborting bump.");
    }
  }

  shouldComponentUpdate(nextProps) {
    if (nextProps.tagName !== this.props.tagName || nextProps.reversed !== this.props.reversed || nextProps.start !== this.props.start) {
      this.manipulateEventCounterToForceNativeToRefresh(); // force a refresh on the native side

      this.value = undefined;
      return true;
    } // TODO: Please re-introduce the check to avoid updating the content right after an `onChange` call.
    // It was removed in https://github.com/WordPress/gutenberg/pull/12417 to fix undo/redo problem.
    // If the component is changed React side (undo/redo/merging/splitting/custom text actions)
    // we need to make sure the native is updated as well.
    // Also, don't trust the "this.lastContent" as on Android, incomplete text events arrive
    //  with only some of the text, while the virtual keyboard's suggestion system does its magic.
    // ** compare with this.lastContent for optimizing performance by not forcing Aztec with text it already has
    // , but compare with props.value to not lose "half word" text because of Android virtual keyb autosuggestion behavior


    if (typeof nextProps.value !== 'undefined' && typeof this.props.value !== 'undefined' && (!this.comesFromAztec || !this.firedAfterTextChanged) && nextProps.value !== this.props.value) {
      // Gutenberg seems to try to mirror the caret state even on events that only change the content so,
      //  let's force caret update if state has selection set.
      if (typeof nextProps.selectionStart !== 'undefined' && typeof nextProps.selectionEnd !== 'undefined') {
        this.needsSelectionUpdate = true;
      }

      this.manipulateEventCounterToForceNativeToRefresh(); // force a refresh on the native side
    }

    if (!this.comesFromAztec) {
      if (typeof nextProps.selectionStart !== 'undefined' && typeof nextProps.selectionEnd !== 'undefined' && nextProps.selectionStart !== this.props.selectionStart && nextProps.selectionStart !== this.selectionStart && nextProps.__unstableIsSelected) {
        this.needsSelectionUpdate = true;
        this.manipulateEventCounterToForceNativeToRefresh(); // force a refresh on the native side
      }
    }

    return true;
  }

  componentDidMount() {
    // Request focus if wrapping block is selected and parent hasn't inhibited the focus request. This method of focusing
    //  is trying to implement the web-side counterpart of BlockList's `focusTabbable` where the BlockList is focusing an
    //  inputbox by searching the DOM. We don't have the DOM in RN so, using the combination of blockIsSelected and __unstableMobileNoFocusOnMount
    //  to determine if we should focus the RichText.
    if (this.props.blockIsSelected && !this.props.__unstableMobileNoFocusOnMount) {
      this._editor.focus();

      this.onSelectionChange(this.props.selectionStart || 0, this.props.selectionEnd || 0);
    }
  }

  componentWillUnmount() {
    if (this._editor.isFocused()) {
      this._editor.blur();
    }
  }

  componentDidUpdate(prevProps) {
    if (this.props.value !== this.value) {
      this.value = this.props.value;
    }

    const {
      __unstableIsSelected: isSelected
    } = this.props;
    const {
      __unstableIsSelected: prevIsSelected
    } = prevProps;

    if (isSelected && !prevIsSelected) {
      this._editor.focus(); // Update selection props explicitly when component is selected as Aztec won't call onSelectionChange
      // if its internal value hasn't change. When created, default value is 0, 0


      this.onSelectionChange(this.props.selectionStart || 0, this.props.selectionEnd || 0);
    } else if (!isSelected && prevIsSelected) {
      this._editor.blur();
    }
  }

  getHtmlToRender(record, tagName) {
    // Save back to HTML from React tree
    let value = this.valueToFormat(record);

    if (value === undefined) {
      this.manipulateEventCounterToForceNativeToRefresh(); // force a refresh on the native side

      value = '';
    } // On android if content is empty we need to send no content or else the placeholder will not show.


    if (!this.isIOS && (value === '' || value === EMPTY_PARAGRAPH_TAGS)) {
      return '';
    }

    if (tagName) {
      let extraAttributes = ``;

      if (tagName === `ol`) {
        if (this.props.reversed) {
          extraAttributes += ` reversed`;
        }

        if (this.props.start) {
          extraAttributes += ` start=${this.props.start}`;
        }
      }

      value = `<${tagName}${extraAttributes}>${value}</${tagName}>`;
    }

    return value;
  }

  getEditableProps() {
    return {
      // Overridable props.
      style: {},
      className: 'rich-text',
      onKeyDown: () => null
    };
  }

  render() {
    var _baseGlobalStyles$col, _baseGlobalStyles$col2;

    const {
      tagName,
      style,
      __unstableIsSelected: isSelected,
      children,
      getStylesFromColorScheme,
      minWidth,
      maxWidth,
      formatTypes,
      parentBlockStyles,
      accessibilityLabel,
      disableEditingMenu = false,
      baseGlobalStyles
    } = this.props;
    const record = this.getRecord();
    const html = this.getHtmlToRender(record, tagName);
    const editableProps = this.getEditableProps();
    const placeholderStyle = getStylesFromColorScheme(_style.default.richTextPlaceholder, _style.default.richTextPlaceholderDark);
    const {
      color: defaultPlaceholderTextColor
    } = placeholderStyle;
    const {
      color: defaultColor,
      textDecorationColor: defaultTextDecorationColor,
      fontFamily: defaultFontFamily
    } = getStylesFromColorScheme(_style.default.richText, _style.default.richTextDark);
    let selection = null;

    if (this.needsSelectionUpdate) {
      this.needsSelectionUpdate = false;
      selection = {
        start: this.props.selectionStart,
        end: this.props.selectionEnd
      }; // On AztecAndroid, setting the caret to an out-of-bounds position will crash the editor so, let's check for some cases.

      if (!this.isIOS) {
        // The following regular expression is used in Aztec here:
        // https://github.com/wordpress-mobile/AztecEditor-Android/blob/b1fad439d56fa6d4aa0b78526fef355c59d00dd3/aztec/src/main/kotlin/org/wordpress/aztec/AztecParser.kt#L656
        const brBeforeParaMatches = html.match(/(<br>)+<\/p>$/g);

        if (brBeforeParaMatches) {
          console.warn('Oops, BR tag(s) at the end of content. Aztec will remove them, adapting the selection...');
          const count = (brBeforeParaMatches[0].match(/br/g) || []).length;

          if (count > 0) {
            let newSelectionStart = this.props.selectionStart - count;

            if (newSelectionStart < 0) {
              newSelectionStart = 0;
            }

            let newSelectionEnd = this.props.selectionEnd - count;

            if (newSelectionEnd < 0) {
              newSelectionEnd = 0;
            }

            selection = {
              start: newSelectionStart,
              end: newSelectionEnd
            };
          }
        }
      }
    }

    if (this.comesFromAztec) {
      this.comesFromAztec = false;
      this.firedAfterTextChanged = false;
    } // Logic below assures that `RichText` width will always have equal value when container is almost fully filled.


    const width = maxWidth && this.state.width && maxWidth - this.state.width < 10 ? maxWidth : this.state.width;
    const containerStyles = (style === null || style === void 0 ? void 0 : style.padding) && (style === null || style === void 0 ? void 0 : style.backgroundColor) && {
      padding: style.padding,
      backgroundColor: style.backgroundColor
    };

    const EditableView = props => {
      this.customEditableOnKeyDown = props === null || props === void 0 ? void 0 : props.onKeyDown;
      return (0, _element.createElement)(_element.Fragment, null);
    };

    return (0, _element.createElement)(_reactNative.View, {
      style: containerStyles
    }, children && children({
      isSelected,
      value: record,
      onChange: this.onFormatChange,
      onFocus: () => {},
      editableProps,
      editableTagName: EditableView
    }), (0, _element.createElement)(_reactNativeAztec.default, (0, _extends2.default)({
      accessibilityLabel: accessibilityLabel,
      ref: ref => {
        this._editor = ref;

        if (this.props.setRef) {
          this.props.setRef(ref);
        }
      },
      style: {
        backgroundColor: _style.default.richText.backgroundColor,
        ...style,
        ...(this.isIOS && minWidth && maxWidth ? {
          width
        } : {
          maxWidth
        }),
        minHeight: this.state.height
      },
      text: {
        text: html,
        eventCount: this.lastEventCount,
        selection,
        linkTextColor: (style === null || style === void 0 ? void 0 : style.linkColor) || defaultTextDecorationColor
      },
      placeholder: this.props.placeholder,
      placeholderTextColor: (style === null || style === void 0 ? void 0 : style.placeholderColor) || this.props.placeholderTextColor || baseGlobalStyles && (baseGlobalStyles === null || baseGlobalStyles === void 0 ? void 0 : (_baseGlobalStyles$col = baseGlobalStyles.color) === null || _baseGlobalStyles$col === void 0 ? void 0 : _baseGlobalStyles$col.text) || defaultPlaceholderTextColor,
      deleteEnter: this.props.deleteEnter,
      onChange: this.onChangeFromAztec,
      onFocus: this.onFocus,
      onBlur: this.onBlur,
      onKeyDown: this.onKeyDown,
      triggerKeyCodes: disableEditingMenu ? [] : this.suggestionOptions().map(op => op.triggerChar),
      onPaste: this.onPaste,
      activeFormats: this.getActiveFormatNames(record),
      onContentSizeChange: this.onContentSizeChange,
      onCaretVerticalPositionChange: this.props.onCaretVerticalPositionChange,
      onSelectionChange: this.onSelectionChangeFromAztec,
      blockType: {
        tag: tagName
      },
      color: style && style.color || parentBlockStyles && parentBlockStyles.color || baseGlobalStyles && (baseGlobalStyles === null || baseGlobalStyles === void 0 ? void 0 : (_baseGlobalStyles$col2 = baseGlobalStyles.color) === null || _baseGlobalStyles$col2 === void 0 ? void 0 : _baseGlobalStyles$col2.text) || defaultColor,
      maxImagesWidth: 200,
      fontFamily: this.props.fontFamily || defaultFontFamily,
      fontSize: this.props.fontSize || style && this.convertFontSizeFromString(style.fontSize),
      fontWeight: this.props.fontWeight,
      fontStyle: this.props.fontStyle,
      disableEditingMenu: disableEditingMenu,
      isMultiline: this.isMultiline,
      textAlign: this.props.textAlign
    }, this.isIOS ? {
      maxWidth
    } : {}, {
      minWidth: minWidth,
      id: this.props.id,
      selectionColor: this.props.selectionColor
    })), isSelected && (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)(_formatEdit.default, {
      formatTypes: formatTypes,
      value: record,
      onChange: this.onFormatChange,
      onFocus: () => {}
    }), (0, _element.createElement)(_blockEditor.BlockFormatControls, null, (0, _element.createElement)(_toolbarButtonWithOptions.default, {
      options: this.suggestionOptions()
    }))));
  }

}

exports.RichText = RichText;
RichText.defaultProps = {
  format: 'string',
  value: '',
  tagName: 'div'
};

const withFormatTypes = WrappedComponent => props => {
  const {
    formatTypes
  } = (0, _useFormatTypes.useFormatTypes)({
    clientId: props.clientId,
    identifier: props.identifier,
    withoutInteractiveFormatting: props.withoutInteractiveFormatting
  });
  return (0, _element.createElement)(WrappedComponent, (0, _extends2.default)({}, props, {
    formatTypes: formatTypes
  }));
};

var _default = (0, _compose.compose)([(0, _data.withSelect)((select, {
  clientId
}) => {
  var _getSettings;

  const {
    getBlockParents,
    getBlock,
    getSettings
  } = select('core/block-editor');
  const parents = getBlockParents(clientId, true);
  const parentBlock = parents ? getBlock(parents[0]) : undefined;
  const parentBlockStyles = (0, _lodash.get)(parentBlock, ['attributes', 'childrenStyles']);
  const baseGlobalStyles = (_getSettings = getSettings()) === null || _getSettings === void 0 ? void 0 : _getSettings.__experimentalGlobalStylesBaseStyles;
  return {
    areMentionsSupported: getSettings('capabilities').mentions === true,
    areXPostsSupported: getSettings('capabilities').xposts === true,
    ...{
      parentBlockStyles
    },
    baseGlobalStyles
  };
}), _compose.withPreferredColorScheme, withFormatTypes])(RichText);

exports.default = _default;
//# sourceMappingURL=index.native.js.map