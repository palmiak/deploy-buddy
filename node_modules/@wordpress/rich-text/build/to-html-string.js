"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toHTMLString = toHTMLString;

var _escapeHtml = require("@wordpress/escape-html");

var _toTree = require("./to-tree");

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/** @typedef {import('./create').RichTextValue} RichTextValue */

/**
 * Create an HTML string from a Rich Text value. If a `multilineTag` is
 * provided, text separated by a line separator will be wrapped in it.
 *
 * @param {Object}        $1                      Named argements.
 * @param {RichTextValue} $1.value                Rich text value.
 * @param {string}        [$1.multilineTag]       Multiline tag.
 * @param {boolean}       [$1.preserveWhiteSpace] Whether or not to use newline
 *                                                characters for line breaks.
 *
 * @return {string} HTML string.
 */
function toHTMLString({
  value,
  multilineTag,
  preserveWhiteSpace
}) {
  const tree = (0, _toTree.toTree)({
    value,
    multilineTag,
    preserveWhiteSpace,
    createEmpty,
    append,
    getLastChild,
    getParent,
    isText,
    getText,
    remove,
    appendText
  });
  return createChildrenHTML(tree.children);
}

function createEmpty() {
  return {};
}

function getLastChild({
  children
}) {
  return children && children[children.length - 1];
}

function append(parent, object) {
  if (typeof object === 'string') {
    object = {
      text: object
    };
  }

  object.parent = parent;
  parent.children = parent.children || [];
  parent.children.push(object);
  return object;
}

function appendText(object, text) {
  object.text += text;
}

function getParent({
  parent
}) {
  return parent;
}

function isText({
  text
}) {
  return typeof text === 'string';
}

function getText({
  text
}) {
  return text;
}

function remove(object) {
  const index = object.parent.children.indexOf(object);

  if (index !== -1) {
    object.parent.children.splice(index, 1);
  }

  return object;
}

function createElementHTML({
  type,
  attributes,
  object,
  children
}) {
  let attributeString = '';

  for (const key in attributes) {
    if (!(0, _escapeHtml.isValidAttributeName)(key)) {
      continue;
    }

    attributeString += ` ${key}="${(0, _escapeHtml.escapeAttribute)(attributes[key])}"`;
  }

  if (object) {
    return `<${type}${attributeString}>`;
  }

  return `<${type}${attributeString}>${createChildrenHTML(children)}</${type}>`;
}

function createChildrenHTML(children = []) {
  return children.map(child => {
    if (child.html !== undefined) {
      return child.html;
    }

    return child.text === undefined ? createElementHTML(child) : (0, _escapeHtml.escapeEditableHTML)(child.text);
  }).join('');
}
//# sourceMappingURL=to-html-string.js.map