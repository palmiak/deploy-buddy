{"version":3,"sources":["@wordpress/rich-text/src/split.js"],"names":["split","formats","replacements","text","start","end","string","splitAtSelection","arguments","nextStart","map","substring","startIndex","value","slice","length","undefined","endIndex","before","after"],"mappings":";;;;;;;AAIA;;AAJA;AACA;AACA;;AAIA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASA,KAAT,CAAgB;AAAEC,EAAAA,OAAF;AAAWC,EAAAA,YAAX;AAAyBC,EAAAA,IAAzB;AAA+BC,EAAAA,KAA/B;AAAsCC,EAAAA;AAAtC,CAAhB,EAA6DC,MAA7D,EAAsE;AAC5E,MAAK,OAAOA,MAAP,KAAkB,QAAvB,EAAkC;AACjC,WAAOC,gBAAgB,CAAE,GAAGC,SAAL,CAAvB;AACA;;AAED,MAAIC,SAAS,GAAG,CAAhB;AAEA,SAAON,IAAI,CAACH,KAAL,CAAYM,MAAZ,EAAqBI,GAArB,CAA4BC,SAAF,IAAiB;AACjD,UAAMC,UAAU,GAAGH,SAAnB;AACA,UAAMI,KAAK,GAAG;AACbZ,MAAAA,OAAO,EAAEA,OAAO,CAACa,KAAR,CAAeF,UAAf,EAA2BA,UAAU,GAAGD,SAAS,CAACI,MAAlD,CADI;AAEbb,MAAAA,YAAY,EAAEA,YAAY,CAACY,KAAb,CACbF,UADa,EAEbA,UAAU,GAAGD,SAAS,CAACI,MAFV,CAFD;AAMbZ,MAAAA,IAAI,EAAEQ;AANO,KAAd;AASAF,IAAAA,SAAS,IAAIH,MAAM,CAACS,MAAP,GAAgBJ,SAAS,CAACI,MAAvC;;AAEA,QAAKX,KAAK,KAAKY,SAAV,IAAuBX,GAAG,KAAKW,SAApC,EAAgD;AAC/C,UAAKZ,KAAK,IAAIQ,UAAT,IAAuBR,KAAK,GAAGK,SAApC,EAAgD;AAC/CI,QAAAA,KAAK,CAACT,KAAN,GAAcA,KAAK,GAAGQ,UAAtB;AACA,OAFD,MAEO,IAAKR,KAAK,GAAGQ,UAAR,IAAsBP,GAAG,GAAGO,UAAjC,EAA8C;AACpDC,QAAAA,KAAK,CAACT,KAAN,GAAc,CAAd;AACA;;AAED,UAAKC,GAAG,IAAIO,UAAP,IAAqBP,GAAG,GAAGI,SAAhC,EAA4C;AAC3CI,QAAAA,KAAK,CAACR,GAAN,GAAYA,GAAG,GAAGO,UAAlB;AACA,OAFD,MAEO,IAAKR,KAAK,GAAGK,SAAR,IAAqBJ,GAAG,GAAGI,SAAhC,EAA4C;AAClDI,QAAAA,KAAK,CAACR,GAAN,GAAYM,SAAS,CAACI,MAAtB;AACA;AACD;;AAED,WAAOF,KAAP;AACA,GA5BM,CAAP;AA6BA;;AAED,SAASN,gBAAT,CACC;AAAEN,EAAAA,OAAF;AAAWC,EAAAA,YAAX;AAAyBC,EAAAA,IAAzB;AAA+BC,EAAAA,KAA/B;AAAsCC,EAAAA;AAAtC,CADD,EAECO,UAAU,GAAGR,KAFd,EAGCa,QAAQ,GAAGZ,GAHZ,EAIE;AACD,MAAKD,KAAK,KAAKY,SAAV,IAAuBX,GAAG,KAAKW,SAApC,EAAgD;AAC/C;AACA;;AAED,QAAME,MAAM,GAAG;AACdjB,IAAAA,OAAO,EAAEA,OAAO,CAACa,KAAR,CAAe,CAAf,EAAkBF,UAAlB,CADK;AAEdV,IAAAA,YAAY,EAAEA,YAAY,CAACY,KAAb,CAAoB,CAApB,EAAuBF,UAAvB,CAFA;AAGdT,IAAAA,IAAI,EAAEA,IAAI,CAACW,KAAL,CAAY,CAAZ,EAAeF,UAAf;AAHQ,GAAf;AAKA,QAAMO,KAAK,GAAG;AACblB,IAAAA,OAAO,EAAEA,OAAO,CAACa,KAAR,CAAeG,QAAf,CADI;AAEbf,IAAAA,YAAY,EAAEA,YAAY,CAACY,KAAb,CAAoBG,QAApB,CAFD;AAGbd,IAAAA,IAAI,EAAEA,IAAI,CAACW,KAAL,CAAYG,QAAZ,CAHO;AAIbb,IAAAA,KAAK,EAAE,CAJM;AAKbC,IAAAA,GAAG,EAAE;AALQ,GAAd;AAQA,SAAO,CACN;AACA,wBAASa,MAAT,EAAiB,UAAjB,EAA6B,EAA7B,CAFM,EAGN,sBAASC,KAAT,EAAgB,UAAhB,EAA4B,EAA5B,CAHM,CAAP;AAKA","sourcesContent":["/**\n * Internal dependencies\n */\n\nimport { replace } from './replace';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Split a Rich Text value in two at the given `startIndex` and `endIndex`, or\n * split at the given separator. This is similar to `String.prototype.split`.\n * Indices are retrieved from the selection if none are provided.\n *\n * @param {RichTextValue} value\n * @param {number|string} [string] Start index, or string at which to split.\n *\n * @return {Array<RichTextValue>|undefined} An array of new values.\n */\nexport function split( { formats, replacements, text, start, end }, string ) {\n\tif ( typeof string !== 'string' ) {\n\t\treturn splitAtSelection( ...arguments );\n\t}\n\n\tlet nextStart = 0;\n\n\treturn text.split( string ).map( ( substring ) => {\n\t\tconst startIndex = nextStart;\n\t\tconst value = {\n\t\t\tformats: formats.slice( startIndex, startIndex + substring.length ),\n\t\t\treplacements: replacements.slice(\n\t\t\t\tstartIndex,\n\t\t\t\tstartIndex + substring.length\n\t\t\t),\n\t\t\ttext: substring,\n\t\t};\n\n\t\tnextStart += string.length + substring.length;\n\n\t\tif ( start !== undefined && end !== undefined ) {\n\t\t\tif ( start >= startIndex && start < nextStart ) {\n\t\t\t\tvalue.start = start - startIndex;\n\t\t\t} else if ( start < startIndex && end > startIndex ) {\n\t\t\t\tvalue.start = 0;\n\t\t\t}\n\n\t\t\tif ( end >= startIndex && end < nextStart ) {\n\t\t\t\tvalue.end = end - startIndex;\n\t\t\t} else if ( start < nextStart && end > nextStart ) {\n\t\t\t\tvalue.end = substring.length;\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t} );\n}\n\nfunction splitAtSelection(\n\t{ formats, replacements, text, start, end },\n\tstartIndex = start,\n\tendIndex = end\n) {\n\tif ( start === undefined || end === undefined ) {\n\t\treturn;\n\t}\n\n\tconst before = {\n\t\tformats: formats.slice( 0, startIndex ),\n\t\treplacements: replacements.slice( 0, startIndex ),\n\t\ttext: text.slice( 0, startIndex ),\n\t};\n\tconst after = {\n\t\tformats: formats.slice( endIndex ),\n\t\treplacements: replacements.slice( endIndex ),\n\t\ttext: text.slice( endIndex ),\n\t\tstart: 0,\n\t\tend: 0,\n\t};\n\n\treturn [\n\t\t// Ensure newlines are trimmed.\n\t\treplace( before, /\\u2028+$/, '' ),\n\t\treplace( after, /^\\u2028+/, '' ),\n\t];\n}\n"]}