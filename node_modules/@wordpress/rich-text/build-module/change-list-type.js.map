{"version":3,"sources":["@wordpress/rich-text/src/change-list-type.js"],"names":["LINE_SEPARATOR","getLineIndex","getParentLineIndex","changeListType","value","newFormat","text","replacements","start","end","startingLineIndex","startLineFormats","endLineFormats","startIndex","newReplacements","slice","startCount","length","endCount","changed","index","map","format","i"],"mappings":"AAAA;AACA;AACA;AAEA,SAASA,cAAT,QAA+B,sBAA/B;AACA,SAASC,YAAT,QAA6B,kBAA7B;AACA,SAASC,kBAAT,QAAmC,yBAAnC;AAEA;;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,cAAT,CAAyBC,KAAzB,EAAgCC,SAAhC,EAA4C;AAClD,QAAM;AAAEC,IAAAA,IAAF;AAAQC,IAAAA,YAAR;AAAsBC,IAAAA,KAAtB;AAA6BC,IAAAA;AAA7B,MAAqCL,KAA3C;AACA,QAAMM,iBAAiB,GAAGT,YAAY,CAAEG,KAAF,EAASI,KAAT,CAAtC;AACA,QAAMG,gBAAgB,GAAGJ,YAAY,CAAEG,iBAAF,CAAZ,IAAqC,EAA9D;AACA,QAAME,cAAc,GAAGL,YAAY,CAAEN,YAAY,CAAEG,KAAF,EAASK,GAAT,CAAd,CAAZ,IAA8C,EAArE;AACA,QAAMI,UAAU,GAAGX,kBAAkB,CAAEE,KAAF,EAASM,iBAAT,CAArC;AACA,QAAMI,eAAe,GAAGP,YAAY,CAACQ,KAAb,EAAxB;AACA,QAAMC,UAAU,GAAGL,gBAAgB,CAACM,MAAjB,GAA0B,CAA7C;AACA,QAAMC,QAAQ,GAAGN,cAAc,CAACK,MAAf,GAAwB,CAAzC;AAEA,MAAIE,OAAJ;;AAEA,OAAM,IAAIC,KAAK,GAAGP,UAAU,GAAG,CAAb,IAAkB,CAApC,EAAuCO,KAAK,GAAGd,IAAI,CAACW,MAApD,EAA4DG,KAAK,EAAjE,EAAsE;AACrE,QAAKd,IAAI,CAAEc,KAAF,CAAJ,KAAkBpB,cAAvB,EAAwC;AACvC;AACA;;AAED,QAAK,CAAEc,eAAe,CAAEM,KAAF,CAAf,IAA4B,EAA9B,EAAmCH,MAAnC,IAA6CD,UAAlD,EAA+D;AAC9D;AACA;;AAED,QAAK,CAAEF,eAAe,CAAEM,KAAF,CAAtB,EAAkC;AACjC;AACA;;AAEDD,IAAAA,OAAO,GAAG,IAAV;AACAL,IAAAA,eAAe,CAAEM,KAAF,CAAf,GAA2BN,eAAe,CAAEM,KAAF,CAAf,CAAyBC,GAAzB,CAC1B,CAAEC,MAAF,EAAUC,CAAV,KAAiB;AAChB,aAAOA,CAAC,GAAGP,UAAJ,IAAkBO,CAAC,GAAGL,QAAtB,GAAiCI,MAAjC,GAA0CjB,SAAjD;AACA,KAHyB,CAA3B;AAKA;;AAED,MAAK,CAAEc,OAAP,EAAiB;AAChB,WAAOf,KAAP;AACA;;AAED,SAAO,EACN,GAAGA,KADG;AAENG,IAAAA,YAAY,EAAEO;AAFR,GAAP;AAIA","sourcesContent":["/**\n * Internal dependencies\n */\n\nimport { LINE_SEPARATOR } from './special-characters';\nimport { getLineIndex } from './get-line-index';\nimport { getParentLineIndex } from './get-parent-line-index';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n/** @typedef {import('./create').RichTextFormat} RichTextFormat */\n\n/**\n * Changes the list type of the selected indented list, if any. Looks at the\n * currently selected list item and takes the parent list, then changes the list\n * type of this list. When multiple lines are selected, the parent lists are\n * takes and changed.\n *\n * @param {RichTextValue}  value     Value to change.\n * @param {RichTextFormat} newFormat The new list format object. Choose between\n *                                   `{ type: 'ol' }` and `{ type: 'ul' }`.\n *\n * @return {RichTextValue} The changed value.\n */\nexport function changeListType( value, newFormat ) {\n\tconst { text, replacements, start, end } = value;\n\tconst startingLineIndex = getLineIndex( value, start );\n\tconst startLineFormats = replacements[ startingLineIndex ] || [];\n\tconst endLineFormats = replacements[ getLineIndex( value, end ) ] || [];\n\tconst startIndex = getParentLineIndex( value, startingLineIndex );\n\tconst newReplacements = replacements.slice();\n\tconst startCount = startLineFormats.length - 1;\n\tconst endCount = endLineFormats.length - 1;\n\n\tlet changed;\n\n\tfor ( let index = startIndex + 1 || 0; index < text.length; index++ ) {\n\t\tif ( text[ index ] !== LINE_SEPARATOR ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( ( newReplacements[ index ] || [] ).length <= startCount ) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif ( ! newReplacements[ index ] ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tchanged = true;\n\t\tnewReplacements[ index ] = newReplacements[ index ].map(\n\t\t\t( format, i ) => {\n\t\t\t\treturn i < startCount || i > endCount ? format : newFormat;\n\t\t\t}\n\t\t);\n\t}\n\n\tif ( ! changed ) {\n\t\treturn value;\n\t}\n\n\treturn {\n\t\t...value,\n\t\treplacements: newReplacements,\n\t};\n}\n"]}