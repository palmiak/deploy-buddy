"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isOfType = isOfType;
exports.isOfTypes = isOfTypes;
exports.getBlockAttribute = getBlockAttribute;
exports.isValidByType = isValidByType;
exports.isValidByEnum = isValidByEnum;
exports.matcherFromSource = matcherFromSource;
exports.parseWithAttributeSchema = parseWithAttributeSchema;
exports.getBlockAttributes = getBlockAttributes;
exports.toBooleanAttributeMatcher = void 0;

var _hpq = require("hpq");

var _lodash = require("lodash");

var _hooks = require("@wordpress/hooks");

var _matchers = require("../matchers");

var _utils = require("../utils");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/**
 * Higher-order hpq matcher which enhances an attribute matcher to return true
 * or false depending on whether the original matcher returns undefined. This
 * is useful for boolean attributes (e.g. disabled) whose attribute values may
 * be technically falsey (empty string), though their mere presence should be
 * enough to infer as true.
 *
 * @param {Function} matcher Original hpq matcher.
 *
 * @return {Function} Enhanced hpq matcher.
 */
const toBooleanAttributeMatcher = matcher => (0, _lodash.flow)([matcher, // Expected values from `attr( 'disabled' )`:
//
// <input>
// - Value:       `undefined`
// - Transformed: `false`
//
// <input disabled>
// - Value:       `''`
// - Transformed: `true`
//
// <input disabled="disabled">
// - Value:       `'disabled'`
// - Transformed: `true`
value => value !== undefined]);
/**
 * Returns true if value is of the given JSON schema type, or false otherwise.
 *
 * @see http://json-schema.org/latest/json-schema-validation.html#rfc.section.6.25
 *
 * @param {*}      value Value to test.
 * @param {string} type  Type to test.
 *
 * @return {boolean} Whether value is of type.
 */


exports.toBooleanAttributeMatcher = toBooleanAttributeMatcher;

function isOfType(value, type) {
  switch (type) {
    case 'string':
      return typeof value === 'string';

    case 'boolean':
      return typeof value === 'boolean';

    case 'object':
      return !!value && value.constructor === Object;

    case 'null':
      return value === null;

    case 'array':
      return Array.isArray(value);

    case 'integer':
    case 'number':
      return typeof value === 'number';
  }

  return true;
}
/**
 * Returns true if value is of an array of given JSON schema types, or false
 * otherwise.
 *
 * @see http://json-schema.org/latest/json-schema-validation.html#rfc.section.6.25
 *
 * @param {*}        value Value to test.
 * @param {string[]} types Types to test.
 *
 * @return {boolean} Whether value is of types.
 */


function isOfTypes(value, types) {
  return types.some(type => isOfType(value, type));
}
/**
 * Given an attribute key, an attribute's schema, a block's raw content and the
 * commentAttributes returns the attribute value depending on its source
 * definition of the given attribute key.
 *
 * @param {string} attributeKey      Attribute key.
 * @param {Object} attributeSchema   Attribute's schema.
 * @param {string} innerHTML         Block's raw content.
 * @param {Object} commentAttributes Block's comment attributes.
 *
 * @return {*} Attribute value.
 */


function getBlockAttribute(attributeKey, attributeSchema, innerHTML, commentAttributes) {
  const {
    type,
    enum: enumSet
  } = attributeSchema;
  let value;

  switch (attributeSchema.source) {
    // An undefined source means that it's an attribute serialized to the
    // block's "comment".
    case undefined:
      value = commentAttributes ? commentAttributes[attributeKey] : undefined;
      break;

    case 'attribute':
    case 'property':
    case 'html':
    case 'text':
    case 'children':
    case 'node':
    case 'query':
    case 'tag':
      value = parseWithAttributeSchema(innerHTML, attributeSchema);
      break;
  }

  if (!isValidByType(value, type) || !isValidByEnum(value, enumSet)) {
    // Reject the value if it is not valid. Reverting to the undefined
    // value ensures the default is respected, if applicable.
    value = undefined;
  }

  if (value === undefined) {
    return attributeSchema.default;
  }

  return value;
}
/**
 * Returns true if value is valid per the given block attribute schema type
 * definition, or false otherwise.
 *
 * @see https://json-schema.org/latest/json-schema-validation.html#rfc.section.6.1.1
 *
 * @param {*}                       value Value to test.
 * @param {?(Array<string>|string)} type  Block attribute schema type.
 *
 * @return {boolean} Whether value is valid.
 */


function isValidByType(value, type) {
  return type === undefined || isOfTypes(value, (0, _lodash.castArray)(type));
}
/**
 * Returns true if value is valid per the given block attribute schema enum
 * definition, or false otherwise.
 *
 * @see https://json-schema.org/latest/json-schema-validation.html#rfc.section.6.1.2
 *
 * @param {*}      value   Value to test.
 * @param {?Array} enumSet Block attribute schema enum.
 *
 * @return {boolean} Whether value is valid.
 */


function isValidByEnum(value, enumSet) {
  return !Array.isArray(enumSet) || enumSet.includes(value);
}
/**
 * Returns an hpq matcher given a source object.
 *
 * @param {Object} sourceConfig Attribute Source object.
 *
 * @return {Function} A hpq Matcher.
 */


function matcherFromSource(sourceConfig) {
  switch (sourceConfig.source) {
    case 'attribute':
      let matcher = (0, _matchers.attr)(sourceConfig.selector, sourceConfig.attribute);

      if (sourceConfig.type === 'boolean') {
        matcher = toBooleanAttributeMatcher(matcher);
      }

      return matcher;

    case 'html':
      return (0, _matchers.html)(sourceConfig.selector, sourceConfig.multiline);

    case 'text':
      return (0, _matchers.text)(sourceConfig.selector);

    case 'children':
      return (0, _matchers.children)(sourceConfig.selector);

    case 'node':
      return (0, _matchers.node)(sourceConfig.selector);

    case 'query':
      const subMatchers = (0, _lodash.mapValues)(sourceConfig.query, matcherFromSource);
      return (0, _matchers.query)(sourceConfig.selector, subMatchers);

    case 'tag':
      return (0, _lodash.flow)([(0, _matchers.prop)(sourceConfig.selector, 'nodeName'), nodeName => nodeName ? nodeName.toLowerCase() : undefined]);

    default:
      // eslint-disable-next-line no-console
      console.error(`Unknown source type "${sourceConfig.source}"`);
  }
}
/**
 * Given a block's raw content and an attribute's schema returns the attribute's
 * value depending on its source.
 *
 * @param {string} innerHTML       Block's raw content.
 * @param {Object} attributeSchema Attribute's schema.
 *
 * @return {*} Attribute value.
 */


function parseWithAttributeSchema(innerHTML, attributeSchema) {
  return (0, _hpq.parse)(innerHTML, matcherFromSource(attributeSchema));
}
/**
 * Returns the block attributes of a registered block node given its type.
 *
 * @param {string|Object} blockTypeOrName Block type or name.
 * @param {string}        innerHTML       Raw block content.
 * @param {?Object}       attributes      Known block attributes (from delimiters).
 *
 * @return {Object} All block attributes.
 */


function getBlockAttributes(blockTypeOrName, innerHTML, attributes = {}) {
  const blockType = (0, _utils.normalizeBlockType)(blockTypeOrName);
  const blockAttributes = (0, _lodash.mapValues)(blockType.attributes, (attributeSchema, attributeKey) => {
    return getBlockAttribute(attributeKey, attributeSchema, innerHTML, attributes);
  });
  return (0, _hooks.applyFilters)('blocks.getBlockAttributes', blockAttributes, blockType, innerHTML, attributes);
}
//# sourceMappingURL=get-block-attributes.js.map