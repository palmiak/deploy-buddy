{"version":3,"sources":["@wordpress/dom/src/tabbable.js"],"names":["without","first","last","find","findFocusable","getTabIndex","element","tabIndex","getAttribute","parseInt","isTabbableIndex","createStatefulCollapseRadioGroup","CHOSEN_RADIO_BY_NAME","collapseRadioGroup","result","nodeName","type","checked","name","concat","hasChosen","hasOwnProperty","isChosen","hadChosenElement","mapElementToObjectTabbable","index","mapObjectTabbableToElement","object","compareObjectTabbables","a","b","aTabIndex","bTabIndex","filterTabbable","focusables","filter","map","sort","reduce","context","findPrevious","ownerDocument","body","indexOf","length","findNext","remaining","slice","node","contains"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { without, first, last } from 'lodash';\n\n/**\n * Internal dependencies\n */\nimport { find as findFocusable } from './focusable';\n\n/**\n * Returns the tab index of the given element. In contrast with the tabIndex\n * property, this normalizes the default (0) to avoid browser inconsistencies,\n * operating under the assumption that this function is only ever called with a\n * focusable node.\n *\n * @see https://bugzilla.mozilla.org/show_bug.cgi?id=1190261\n *\n * @param {Element} element Element from which to retrieve.\n *\n * @return {number} Tab index of element (default 0).\n */\nfunction getTabIndex( element ) {\n\tconst tabIndex = element.getAttribute( 'tabindex' );\n\treturn tabIndex === null ? 0 : parseInt( tabIndex, 10 );\n}\n\n/**\n * Returns true if the specified element is tabbable, or false otherwise.\n *\n * @param {Element} element Element to test.\n *\n * @return {boolean} Whether element is tabbable.\n */\nexport function isTabbableIndex( element ) {\n\treturn getTabIndex( element ) !== -1;\n}\n\n/** @typedef {Element & { type?: string, checked?: boolean, name?: string }} MaybeHTMLInputElement */\n\n/**\n * Returns a stateful reducer function which constructs a filtered array of\n * tabbable elements, where at most one radio input is selected for a given\n * name, giving priority to checked input, falling back to the first\n * encountered.\n *\n * @return {(acc: MaybeHTMLInputElement[], el: MaybeHTMLInputElement) => MaybeHTMLInputElement[]} Radio group collapse reducer.\n */\nfunction createStatefulCollapseRadioGroup() {\n\t/** @type {Record<string, MaybeHTMLInputElement>} */\n\tconst CHOSEN_RADIO_BY_NAME = {};\n\n\treturn function collapseRadioGroup(\n\t\t/** @type {MaybeHTMLInputElement[]} */ result,\n\t\t/** @type {MaybeHTMLInputElement} */ element\n\t) {\n\t\tconst { nodeName, type, checked, name } = element;\n\n\t\t// For all non-radio tabbables, construct to array by concatenating.\n\t\tif ( nodeName !== 'INPUT' || type !== 'radio' || ! name ) {\n\t\t\treturn result.concat( element );\n\t\t}\n\n\t\tconst hasChosen = CHOSEN_RADIO_BY_NAME.hasOwnProperty( name );\n\n\t\t// Omit by skipping concatenation if the radio element is not chosen.\n\t\tconst isChosen = checked || ! hasChosen;\n\t\tif ( ! isChosen ) {\n\t\t\treturn result;\n\t\t}\n\n\t\t// At this point, if there had been a chosen element, the current\n\t\t// element is checked and should take priority. Retroactively remove\n\t\t// the element which had previously been considered the chosen one.\n\t\tif ( hasChosen ) {\n\t\t\tconst hadChosenElement = CHOSEN_RADIO_BY_NAME[ name ];\n\t\t\tresult = without( result, hadChosenElement );\n\t\t}\n\n\t\tCHOSEN_RADIO_BY_NAME[ name ] = element;\n\n\t\treturn result.concat( element );\n\t};\n}\n\n/**\n * An array map callback, returning an object with the element value and its\n * array index location as properties. This is used to emulate a proper stable\n * sort where equal tabIndex should be left in order of their occurrence in the\n * document.\n *\n * @param {Element} element Element.\n * @param {number}  index   Array index of element.\n *\n * @return {{ element: Element, index: number }} Mapped object with element, index.\n */\nfunction mapElementToObjectTabbable( element, index ) {\n\treturn { element, index };\n}\n\n/**\n * An array map callback, returning an element of the given mapped object's\n * element value.\n *\n * @param {{ element: Element }} object Mapped object with element.\n *\n * @return {Element} Mapped object element.\n */\nfunction mapObjectTabbableToElement( object ) {\n\treturn object.element;\n}\n\n/**\n * A sort comparator function used in comparing two objects of mapped elements.\n *\n * @see mapElementToObjectTabbable\n *\n * @param {{ element: Element, index: number }} a First object to compare.\n * @param {{ element: Element, index: number }} b Second object to compare.\n *\n * @return {number} Comparator result.\n */\nfunction compareObjectTabbables( a, b ) {\n\tconst aTabIndex = getTabIndex( a.element );\n\tconst bTabIndex = getTabIndex( b.element );\n\n\tif ( aTabIndex === bTabIndex ) {\n\t\treturn a.index - b.index;\n\t}\n\n\treturn aTabIndex - bTabIndex;\n}\n\n/**\n * Givin focusable elements, filters out tabbable element.\n *\n * @param {Element[]} focusables Focusable elements to filter.\n *\n * @return {Element[]} Tabbable elements.\n */\nfunction filterTabbable( focusables ) {\n\treturn focusables\n\t\t.filter( isTabbableIndex )\n\t\t.map( mapElementToObjectTabbable )\n\t\t.sort( compareObjectTabbables )\n\t\t.map( mapObjectTabbableToElement )\n\t\t.reduce( createStatefulCollapseRadioGroup(), [] );\n}\n\n/**\n * @param {Element} context\n * @return {Element[]} Tabbable elements within the context.\n */\nexport function find( context ) {\n\treturn filterTabbable( findFocusable( context ) );\n}\n\n/**\n * Given a focusable element, find the preceding tabbable element.\n *\n * @param {Element} element The focusable element before which to look. Defaults\n *                          to the active element.\n */\nexport function findPrevious( element ) {\n\tconst focusables = findFocusable( element.ownerDocument.body );\n\tconst index = focusables.indexOf( element );\n\n\t// Remove all focusables after and including `element`.\n\tfocusables.length = index;\n\n\treturn last( filterTabbable( focusables ) );\n}\n\n/**\n * Given a focusable element, find the next tabbable element.\n *\n * @param {Element} element The focusable element after which to look. Defaults\n *                          to the active element.\n */\nexport function findNext( element ) {\n\tconst focusables = findFocusable( element.ownerDocument.body );\n\tconst index = focusables.indexOf( element );\n\n\t// Remove all focusables before and inside `element`.\n\tconst remaining = focusables\n\t\t.slice( index + 1 )\n\t\t.filter( ( node ) => ! element.contains( node ) );\n\n\treturn first( filterTabbable( remaining ) );\n}\n"]}